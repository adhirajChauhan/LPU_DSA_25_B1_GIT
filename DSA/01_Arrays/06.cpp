//Time comlpexity -> it is a way to express how the running time of an algorithm increases with the input size.
/*
-> Big O -> represents the upper bound of running time, it gives the worst-case scanerio for an algorithm, (tells maximum time an algo can take)
-> Theta -> average case
-> Omega -> Lower bound -> best case

--> Common time complexities
1. O(1) -> Constant time
cout << "Hello";

2. O(log n) -> Logarithmic time
tiime grows logarithmically as the input size increases, often seen in algorithms that divide the input in half, like binary search

3. O(n) -> Linear time -> time grows directly in proportion to input size

4. O(n log n) -> Linearithmic time -> mix of linear and logarithmic time, common in divide and conquer algos like merge sort or quick sort

5. O(n^2) Quadratic time -> time will grow proportionally to the square of the input size, often seen in algos with nested loop

6. O(2^n) Exponential time -> the time doubles with each adiitional element, common in recursive algos that solves problems by trying all possibilities
*/

#include<iostream>
using namespace std;
 
int main()
{
 
}